# üêª Aprendiendo Zustand con React + TypeScript

¬°Hola! Soy **Forl√°n Ordo√±ez**, desarrollador junior, y en este repositorio encontrar√°s todo lo que voy aprendiendo sobre **Zustand**, una librer√≠a simple y poderosa para manejar el estado global en aplicaciones **React**.

Mi objetivo con este proyecto es:

- Aprender Zustand paso a paso.
- Subir ejemplos pr√°cticos y bien explicados.
- Compartir conocimientos con otros devs que quieran entender y usar Zustand en sus propios proyectos.

Si est√°s empezando con Zustand o quieres una alternativa m√°s simple a Redux, ¬°este repo es para ti!

---

## üìÇ Contenido del repositorio

Por ahora, encontrar√°s ejemplos como:

- Un **contador global** usando Zustand.
- C√≥mo estructurar tu **store** con TypeScript.
- Uso b√°sico de Zustand en componentes.
- Uso de middlewares como **persistencia con localStorage**.

A medida que avance, ir√© agregando m√°s ejemplos como:
- Manejo de datos asincr√≥nicos con `fetch`.
- M√∫ltiples stores.
- Selectores para optimizar renderizados.
- Uso con DevTools, etc.

---

##  C√≥mo ejecutar el proyecto

Este proyecto fue creado con **Vite** y usa **React + TypeScript**.

### üì¶ Requisitos

- Node.js (v16 o superior)
- npm o yarn

### üß™ Pasos para correr el proyecto:

1. **Clonar el repositorio**
```bash
git clone https://github.com/FOOR29/Zustand.git
```

2. **Entrar al directorio del proyecto**
```bash
cd Zustand
```

3. **Instalar las dependencias**
```bash
npm install
# o
yarn
```
4. **Levantar el servidor de desarrollo**
```bash
npm run dev
# o
yarn dev
```
---
<br>
<br>

# üêª Aprendiendo Zustand con React + TypeScript

üí¨ ¬øQu√© es Zustand?

Zustand es una librer√≠a para manejar el estado en React de forma sencilla y sin boilerplate. A diferencia de Redux o Context API, Zustand:

- Es m√°s ligera y f√°cil de usar.

- No requiere reducers ni acciones verbosas.

- Se basa en hooks y es 100% compatible con TypeScript.

- "Zustand" significa "estado" en alem√°n üß†

A diferencia de useState, que maneja estado local a cada componente, Zustand proporciona un estado centralizado que puede ser le√≠do y modificado eficientemente desde diferentes partes de la aplicaci√≥n.
***

## Instalaci√≥n y configuraci√≥n inicial

Para empezar a usar Zustand en un proyecto de React con Vite y TypeScript, sigue estos pasos:

1. **Crear el proyecto React con Vite: Por ejemplo, abre la terminal y ejecuta:**
```bash
npm create vite@latest mi-app-zustand
```
Esto crea un proyecto React + TypeScript usando Vite.

2. **Instalar Zustand: Una vez dentro de la carpeta del proyecto, instala la librer√≠a con:**
```bash
npm install zustand
```

3. **(Opcional) Configurar TypeScript: Zustand ya tiene tipos incluidos, as√≠ que no necesitas pasos extra; solo aseg√∫rate de que tu entorno est√° configurado para TSX/TS.**
---

<br>
<br>

## Creaci√≥n de un store con Zustand
La pr√°ctica com√∫n es crear un directorio dedicado **(por ejemplo, src/store/ o src/stores/)**
<br>
para los archivos de estado global
Dentro de esa carpeta, defines un archivo por cada store o **slice** de estado. Un ejemplo t√≠pico es un contador global: crear√≠amos ***src/store/counterStore.ts.*** All√≠ importamos create de zustand, definimos una interfaz de estado y funciones, y creamos el hook:

![Imagen vscode](./public/img/zustand%20img%201.png)

>En este ejemplo usamos TypeScript para definir CounterState con una propiedad count y dos m√©todos (increment, decrement). La funci√≥n create recibe una funci√≥n que recibe set (y get si se necesita) y devuelve el estado inicial junto con las funciones que modifican el estado. Al final exportamos el hook useCounterStore para usarlo en nuestros componentes.
Cada archivo de store suele tener un solo store (esto mejora la organizaci√≥n)y nombres descriptivos, p.ej. themeStore.ts, userStore.ts.

<br>

## Uso del store en componentes

Una vez definido el store, usarlo es muy sencillo. Simplemente importas el hook generado y lo invocas dentro de un componente para leer el estado o llamar acciones. Por ejemplo, en **App.tsx** podr√≠as hacer:

![Imagen vscode](./public/img/zustand%20cap%202.png)

>Aqu√≠ ***useCounterStore()*** devuelve un objeto con ***{ count, increment, decrement }***. Cada vez que llamas a **increment()** o **decrement()**, el estado cambia y cualquier componente que use count se rerenderiza autom√°ticamente.
Este comportamiento es an√°logo a usar useState en ese componente, pero la diferencia es que si otro componente tambi√©n importa **useCounterStore**, compartir√° el mismo estado global. En cambio, un **useState(0)** dentro de App mantendr√≠a su estado aislado solo para App.

<br>

## Estructura de carpetas recomendada
Una buena pr√°ctica es organizar el c√≥digo por funci√≥n o m√≥dulo. Para Zustand, lo habitual es:

- Crear una carpeta src/store/ o src/stores/ dedicada donde poner todos los archivos de stores

- Dentro, un archivo por store o por ‚Äúslice‚Äù de estado. Por ejemplo, podr√≠as tener:

```
src/
‚îú‚îÄ components/
‚îÇ   ‚îî‚îÄ ...componentes UI...
‚îú‚îÄ store/
‚îÇ   ‚îú themeStore.ts   // store de tema (claro/oscuro)
‚îÇ   ‚îú userStore.ts    // store de usuario
‚îÇ   ‚îî counterStore.ts // store del contador de ejemplo
‚îú‚îÄ App.tsx
‚îî‚îÄ index.tsx
```
- Nombrar los archivos de forma descriptiva y consistente: por ejemplo themeStore.ts, cartStore.ts, userStore.ts.
Dentro de cada archivo, exporta el hook (usualmente en PascalCase, p.ej. useThemeStore)

- Mantener acciones y estado relacionados juntos en el mismo archivo (co-locaci√≥n)

- En apps grandes, es com√∫n agrupar por dominios o p√°ginas; pero para un proyecto peque√±o o de pr√°ctica, la estructura anterior funciona bien y luego puede escalarse a√±adiendo directorios de caracter√≠sticas si hace falta
---

<br>

## Ejemplo pr√°ctico: bot√≥n Modo Oscuro/Claro con Zustand

Supongamos que queremos implementar un bot√≥n que alterna entre tema claro y oscuro en toda la app. Con Zustand, creamos un store para el tema. Por ejemplo, en src/store/themeStore.ts:

![image Vscode](./public/img/zustand%20cap%203.png)

Explicaci√≥n paso a paso:

- Definimos el estado: darkMode es un booleano que indica si estamos en modo oscuro. Iniciamos en false (modo claro).

- Acci√≥n para alternar: toggleDarkMode invierte el valor de darkMode usando set.

- Persistencia (opcional): Usamos persist (de zustand/middleware) para que el valor de darkMode se guarde en localStorage. As√≠, si el usuario recarga la p√°gina, el tema elegido se mantiene y el par√°metro name indica la clave bajo la cual se almacenar√° en el navegador, facilito papa.

Luego, en un componente React **(por ejemplo ThemeButton.tsx)**, importamos el hook y usamos los valores:

> Aqu√≠ el bot√≥n muestra ‚ÄúModo claro‚Äù cuando estamos en modo oscuro (y viceversa) y al hacer clic dispara toggleDarkMode(), que actualiza el estado global. El hook useThemeStore() entrega siempre el mismo estado compartido y la funci√≥n para cambiarlo. Gracias al middleware persist, esta preferencia de tema se recuerda incluso tras recargar la p√°gina.


## Ejemplos cotidianos de uso

Zustand brilla en situaciones donde varios componentes necesitan el mismo dato. Algunos ejemplos comunes:

- Preferencias del usuario: idioma seleccionado, tema (claro/oscuro), configuraciones personales, etc.

- Autenticaci√≥n: estado de si el usuario est√° logueado, su token, roles, etc.

- Carrito de compras: lista de productos seleccionados que deben leerse/escribirse desde diferentes p√°ginas o componentes.

- Datos de perfil o formularios: informaci√≥n que se rellena en varios pasos (multi-step) y debe compartirse en diferentes componentes.

- Contadores y m√©tricas: un contador global (como el de las notificaciones) accesible desde cualquier parte de la interfaz.

En todos estos casos, usar useState local requerir√≠a pasar props o contextos, mientras que con un store de Zustand bastar√≠a con importar el hook y listo

## Resumen de pasos y buenas pr√°cticas

- Instala Zustand: npm install zustand (ya lo explicamos)

- Crea el store: Define un archivo en src/store/ para cada conjunto de datos globales. Usa create() con una interfaz que describa tu estado y acciones

- Usa el hook en tus componentes: Importa el hook generado (p.ej. useThemeStore) y llama al hook dentro de la funci√≥n de tu componente. Desestructura el estado y las funciones que necesites

- Estructura organizada: Mant√©n un directorio espec√≠fico (src/store) y nombra los archivos de forma clara. Un store por archivo suele funcionar mejor

- Middleware √∫til: Considera usar el middleware persist si quieres que parte del estado (como la preferencia de tema) se guarde autom√°ticamente en el navegado

Con estos consejos y ejemplos, deber√≠as poder entender y aplicar Zustand en tu proyecto React con Vite/TypeScript. Es una herramienta poderosa para manejar estados compartidos de forma simple.
